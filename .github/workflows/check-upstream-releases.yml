name: Check Upstream Releases

on:
  schedule:
    # Run every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch: # Allow manual trigger

jobs:
  check_releases:
    runs-on: ubuntu-latest
    outputs:
      has_updates: ${{ steps.check_updates.outputs.has_updates }}
      update_summary: ${{ steps.check_updates.outputs.update_summary }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for upstream releases
        id: check_updates
        run: |
          # Initialize variables
          HAS_UPDATES=false
          UPDATE_SUMMARY=""
          
          # File to store last known versions
          VERSIONS_FILE=".last_known_versions"
          
          # If versions file doesn't exist, create it
          if [ ! -f "$VERSIONS_FILE" ]; then
            touch "$VERSIONS_FILE"
          fi
          
          # Function to get latest release from GitHub
          get_latest_release() {
            local repo=$1
            gh api repos/$repo/releases/latest --jq '.tag_name' 2>/dev/null || echo "unknown"
          }
          
          # Tools to check
          declare -A TOOLS=(
            ["kubectl"]="kubernetes/kubernetes"
            ["helm"]="helm/helm"
            ["jq"]="jqlang/jq"
            ["skopeo"]="containers/skopeo"
            ["oras"]="oras-project/oras"
            ["cosign"]="sigstore/cosign"
            ["flux"]="fluxcd/flux2"
          )
          
          # Check each tool
          for tool in "${!TOOLS[@]}"; do
            repo="${TOOLS[$tool]}"
            echo "Checking $tool from $repo..."
            
            # Get latest release
            LATEST=$(get_latest_release "$repo")
            echo "Latest $tool release: $LATEST"
            
            # Get last known version
            LAST_KNOWN=$(grep "^$tool=" "$VERSIONS_FILE" | cut -d'=' -f2 || echo "")
            
            if [ -z "$LAST_KNOWN" ]; then
              # First time checking this tool
              echo "$tool=$LATEST" >> "$VERSIONS_FILE"
              UPDATE_SUMMARY+="- $tool: New tracking started at $LATEST\n"
            elif [ "$LATEST" != "$LAST_KNOWN" ] && [ "$LATEST" != "unknown" ]; then
              # New version detected
              HAS_UPDATES=true
              UPDATE_SUMMARY+="- $tool: $LAST_KNOWN â†’ $LATEST\n"
              # Update the versions file
              sed -i "s/^$tool=.*/$tool=$LATEST/" "$VERSIONS_FILE"
            fi
          done
          
          # Output results
          echo "has_updates=$HAS_UPDATES" >> $GITHUB_OUTPUT
          echo "update_summary<<EOF" >> $GITHUB_OUTPUT
          echo -e "$UPDATE_SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Commit updated versions file if there are changes
          if [ "$HAS_UPDATES" = "true" ] || [ -n "$UPDATE_SUMMARY" ]; then
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git add "$VERSIONS_FILE"
            git diff --quiet && git diff --staged --quiet || git commit -m "Update last known versions [skip ci]"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Push version updates
        if: steps.check_updates.outputs.has_updates == 'true' || steps.check_updates.outputs.update_summary != ''
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ github.ref }}

  trigger_build:
    needs: check_releases
    if: needs.check_releases.outputs.has_updates == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Get current date
        id: date
        run: echo "date=$(date +'%Y.%m')" >> $GITHUB_OUTPUT

      - name: Create release tag
        run: |
          # Calculate next patch number
          LATEST_TAG=$(gh api repos/${{ github.repository }}/releases/latest --jq '.tag_name' 2>/dev/null || echo "v0.0.0")
          DATE_PREFIX="v${{ steps.date.outputs.date }}"
          
          # Extract patch number if the latest tag matches current month
          if [[ $LATEST_TAG == $DATE_PREFIX.* ]]; then
            PATCH=$(echo $LATEST_TAG | cut -d'.' -f3)
            NEXT_PATCH=$((PATCH + 1))
          else
            NEXT_PATCH=0
          fi
          
          NEW_TAG="${DATE_PREFIX}.${NEXT_PATCH}"
          echo "Creating new release tag: $NEW_TAG"
          
          # Create release notes
          RELEASE_NOTES="## Automated Release - Upstream Updates

${{ needs.check_releases.outputs.update_summary }}

This release was automatically triggered due to upstream updates."
          
          # Create the release (which will trigger the build workflow)
          gh release create "$NEW_TAG" \
            --repo ${{ github.repository }} \
            --title "Release $NEW_TAG - Upstream Updates" \
            --notes "$RELEASE_NOTES"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create issue for upstream updates
        if: always()
        run: |
          ISSUE_TITLE="Upstream Updates Detected - $(date +'%Y-%m-%d')"
          ISSUE_BODY="## Upstream Updates Summary

The following upstream releases were detected:

${{ needs.check_releases.outputs.update_summary }}

A new release has been automatically created which will trigger the build process.

### Next Steps
- Monitor the build workflow for any issues
- Test the new packages once built
- Update documentation if needed

This issue was automatically created by the upstream release checker."
          
          gh issue create \
            --repo ${{ github.repository }} \
            --title "$ISSUE_TITLE" \
            --body "$ISSUE_BODY" \
            --label "upstream-update,automated"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}